# Poseidon2 Linear Layers for KoalaBear Field (Width 16)
#
# Two types of linear layers:
# 1. External (Full rounds): 4x4 MDS applied to chunks + circulant combination
# 2. Internal (Partial rounds): 1 + Diag(V) matrix multiplication

# Include KoalaBear field operations (inline for now)
proc kb_reduce
    dup
    push.0x7F000001
    u32lt
    if.true
    else
        push.0x7F000001
        u32wrapping_sub
    end
end

proc kb_add
    u32overflowing_add
    if.true
        push.0x7F000001
        u32wrapping_sub
    else
        exec.kb_reduce
    end
end

proc kb_mul
    u32overflowing_mul
    dup eq.0
    if.true
        drop
        exec.kb_reduce
    else
        swap swap
        push.33554430
        u32overflowing_mul
        swap movup.2
        u32overflowing_add
        movup.2 add
        dup eq.0
        if.true
            drop
            exec.kb_reduce
        else
            swap swap
            push.33554430
            u32overflowing_mul
            swap movup.2
            u32overflowing_add
            movup.2 add
            dup eq.0
            if.true
                drop
                exec.kb_reduce
            else
                swap swap
                push.33554430
                u32overflowing_mul
                swap movup.2
                u32overflowing_add
                movup.2 add
                dup eq.0
                if.true
                    drop
                    exec.kb_reduce
                else
                    drop
                    exec.kb_reduce
                end
            end
        end
    end
end

# ============================================================================
# apply_mat4: Apply 4x4 MDS matrix to 4 elements on stack
# ============================================================================
# Input:  [x0, x1, x2, x3, ...]
# Output: [y0, y1, y2, y3, ...]
# Matrix: [[2,3,1,1],[1,2,3,1],[1,1,2,3],[3,1,1,2]]
#
# y0 = 2*x0 + 3*x1 + x2 + x3
# y1 = x0 + 2*x1 + 3*x2 + x3
# y2 = x0 + x1 + 2*x2 + 3*x3
# y3 = 3*x0 + x1 + x2 + 2*x3
proc apply_mat4
    # Stack: [x0, x1, x2, x3, ...]
    # Store inputs in memory temporarily (addresses 0-3)
    mem_store.0                 # Store x0
    mem_store.1                 # Store x1
    mem_store.2                 # Store x2
    mem_store.3                 # Store x3
    # Stack: [...]

    # Compute y0 = 2*x0 + 3*x1 + x2 + x3
    mem_load.0 dup exec.kb_add  # 2*x0
    mem_load.1 dup dup exec.kb_add exec.kb_add  # 3*x1
    exec.kb_add                 # 2*x0 + 3*x1
    mem_load.2 exec.kb_add      # + x2
    mem_load.3 exec.kb_add      # + x3 = y0

    # Compute y1 = x0 + 2*x1 + 3*x2 + x3
    mem_load.0                  # x0
    mem_load.1 dup exec.kb_add  # 2*x1
    exec.kb_add                 # x0 + 2*x1
    mem_load.2 dup dup exec.kb_add exec.kb_add  # 3*x2
    exec.kb_add                 # + 3*x2
    mem_load.3 exec.kb_add      # + x3 = y1

    # Compute y2 = x0 + x1 + 2*x2 + 3*x3
    mem_load.0 mem_load.1 exec.kb_add   # x0 + x1
    mem_load.2 dup exec.kb_add          # 2*x2
    exec.kb_add                         # + 2*x2
    mem_load.3 dup dup exec.kb_add exec.kb_add  # 3*x3
    exec.kb_add                         # + 3*x3 = y2

    # Compute y3 = 3*x0 + x1 + x2 + 2*x3
    mem_load.0 dup dup exec.kb_add exec.kb_add  # 3*x0
    mem_load.1 exec.kb_add              # + x1
    mem_load.2 exec.kb_add              # + x2
    mem_load.3 dup exec.kb_add          # 2*x3
    exec.kb_add                         # + 2*x3 = y3

    # Stack: [y3, y2, y1, y0, ...]
    # Reorder to [y0, y1, y2, y3, ...]
    movdn.3                     # [y2, y1, y0, y3, ...]
    movdn.3                     # [y1, y0, y3, y2, ...]
    movdn.3                     # [y0, y3, y2, y1, ...]
    swap                        # [y3, y0, y2, y1, ...]
    movup.2                     # [y2, y3, y0, y1, ...]
    movup.3                     # [y1, y2, y3, y0, ...]
    movdn.3                     # [y2, y3, y0, y1, ...]
    # Hmm this is getting complex. Let me store and reload in correct order.

    # Actually easier: store all 4 and reload
    mem_store.7                 # Store y3
    mem_store.6                 # Store y2
    mem_store.5                 # Store y1
    mem_store.4                 # Store y0

    mem_load.4                  # y0
    mem_load.5                  # y1
    mem_load.6                  # y2
    mem_load.7                  # y3
    # Stack: [y3, y2, y1, y0, ...]
    # We want [y0, y1, y2, y3, ...]
    swap movdn.2 movdn.3
    # That's still not right. Let me think...
    # After 4 loads: [y3, y2, y1, y0, ...]
    # swap: [y2, y3, y1, y0, ...]
    # movdn.2: [y3, y1, y2, y0, ...]
    # movdn.3: [y1, y2, y0, y3, ...]
    # Not correct either.

    # Simpler: use movup to bring y0 to top
    movup.3                     # [y0, y3, y2, y1, ...]
    swap                        # [y3, y0, y2, y1, ...]
    movdn.3                     # [y0, y2, y1, y3, ...]
    movup.2                     # [y1, y0, y2, y3, ...]
    swap                        # [y0, y1, y2, y3, ...]
end

# ============================================================================
# mds_external_16: Apply full external MDS layer for width 16
# ============================================================================
# State stored in memory at addresses 16-31
# This reads state from memory, applies MDS, writes back
proc mds_external_16
    # The external layer for width 16:
    # 1. Apply 4x4 MDS to each 4-element chunk
    # 2. For each i in 0..15: state[i] += sum[i mod 4]
    #    where sum[j] = state[j] + state[j+4] + state[j+8] + state[j+12]

    # Load chunk 0 (elements 0-3)
    mem_load.16 mem_load.17 mem_load.18 mem_load.19
    # Stack: [s3, s2, s1, s0, ...]
    movup.3 movup.3 movup.3     # Reorder to [s0, s1, s2, s3, ...]
    exec.apply_mat4
    mem_store.16 mem_store.17 mem_store.18 mem_store.19

    # Load chunk 1 (elements 4-7)
    mem_load.20 mem_load.21 mem_load.22 mem_load.23
    movup.3 movup.3 movup.3
    exec.apply_mat4
    mem_store.20 mem_store.21 mem_store.22 mem_store.23

    # Load chunk 2 (elements 8-11)
    mem_load.24 mem_load.25 mem_load.26 mem_load.27
    movup.3 movup.3 movup.3
    exec.apply_mat4
    mem_store.24 mem_store.25 mem_store.26 mem_store.27

    # Load chunk 3 (elements 12-15)
    mem_load.28 mem_load.29 mem_load.30 mem_load.31
    movup.3 movup.3 movup.3
    exec.apply_mat4
    mem_store.28 mem_store.29 mem_store.30 mem_store.31

    # Now compute sums and add to each element
    # sum[0] = s[0] + s[4] + s[8] + s[12]
    mem_load.16 mem_load.20 exec.kb_add
    mem_load.24 exec.kb_add mem_load.28 exec.kb_add
    # Stack: [sum0, ...]
    mem_store.8                 # Store sum0 at temp

    # sum[1] = s[1] + s[5] + s[9] + s[13]
    mem_load.17 mem_load.21 exec.kb_add
    mem_load.25 exec.kb_add mem_load.29 exec.kb_add
    mem_store.9

    # sum[2] = s[2] + s[6] + s[10] + s[14]
    mem_load.18 mem_load.22 exec.kb_add
    mem_load.26 exec.kb_add mem_load.30 exec.kb_add
    mem_store.10

    # sum[3] = s[3] + s[7] + s[11] + s[15]
    mem_load.19 mem_load.23 exec.kb_add
    mem_load.27 exec.kb_add mem_load.31 exec.kb_add
    mem_store.11

    # Add sums to each element
    # s[0] += sum[0], s[1] += sum[1], s[2] += sum[2], s[3] += sum[3]
    mem_load.16 mem_load.8 exec.kb_add mem_store.16
    mem_load.17 mem_load.9 exec.kb_add mem_store.17
    mem_load.18 mem_load.10 exec.kb_add mem_store.18
    mem_load.19 mem_load.11 exec.kb_add mem_store.19

    # s[4] += sum[0], s[5] += sum[1], s[6] += sum[2], s[7] += sum[3]
    mem_load.20 mem_load.8 exec.kb_add mem_store.20
    mem_load.21 mem_load.9 exec.kb_add mem_store.21
    mem_load.22 mem_load.10 exec.kb_add mem_store.22
    mem_load.23 mem_load.11 exec.kb_add mem_store.23

    # s[8] += sum[0], etc.
    mem_load.24 mem_load.8 exec.kb_add mem_store.24
    mem_load.25 mem_load.9 exec.kb_add mem_store.25
    mem_load.26 mem_load.10 exec.kb_add mem_store.26
    mem_load.27 mem_load.11 exec.kb_add mem_store.27

    mem_load.28 mem_load.8 exec.kb_add mem_store.28
    mem_load.29 mem_load.9 exec.kb_add mem_store.29
    mem_load.30 mem_load.10 exec.kb_add mem_store.30
    mem_load.31 mem_load.11 exec.kb_add mem_store.31
end

# ============================================================================
# internal_linear_16: Apply internal linear layer (1 + Diag(V))
# ============================================================================
# State stored in memory at addresses 16-31
# Diagonal V stored in memory at addresses 416-431
#
# For each i: new_s[i] = s[i] + v[i] * sum_all
# where sum_all = sum of all s[i]
#
# Wait, that's not correct. Let me check the formula again.
# Actually for 1 + Diag(V):
# output[i] = input[i] + V[i] * input[i] = input[i] * (1 + V[i])
#
# Hmm, but that's just element-wise multiplication.
# Let me re-check the Poseidon2 internal layer...
#
# Actually the internal diffusion in Poseidon2 is:
# 1. Compute sum of all state elements
# 2. For each i: state[i] = state[i] * diag[i] + sum
# (This is the "1 + Diag(V)" formulation where the "1" is represented by adding sum)
proc internal_linear_16
    # Compute sum of all 16 elements
    mem_load.16
    mem_load.17 exec.kb_add
    mem_load.18 exec.kb_add
    mem_load.19 exec.kb_add
    mem_load.20 exec.kb_add
    mem_load.21 exec.kb_add
    mem_load.22 exec.kb_add
    mem_load.23 exec.kb_add
    mem_load.24 exec.kb_add
    mem_load.25 exec.kb_add
    mem_load.26 exec.kb_add
    mem_load.27 exec.kb_add
    mem_load.28 exec.kb_add
    mem_load.29 exec.kb_add
    mem_load.30 exec.kb_add
    mem_load.31 exec.kb_add
    # Stack: [sum, ...]
    mem_store.12                # Store sum at temp address

    # For each element: state[i] = state[i] * diag[i] + sum
    # Element 0: diag at 416
    mem_load.16 mem_load.416 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.16

    mem_load.17 mem_load.417 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.17

    mem_load.18 mem_load.418 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.18

    mem_load.19 mem_load.419 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.19

    mem_load.20 mem_load.420 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.20

    mem_load.21 mem_load.421 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.21

    mem_load.22 mem_load.422 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.22

    mem_load.23 mem_load.423 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.23

    mem_load.24 mem_load.424 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.24

    mem_load.25 mem_load.425 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.25

    mem_load.26 mem_load.426 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.26

    mem_load.27 mem_load.427 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.27

    mem_load.28 mem_load.428 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.28

    mem_load.29 mem_load.429 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.29

    mem_load.30 mem_load.430 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.30

    mem_load.31 mem_load.431 exec.kb_mul
    mem_load.12 exec.kb_add mem_store.31
end
