# Comprehensive KoalaBear Field Arithmetic Tests
# p = 0x7F000001 = 2130706433
#
# Tests all field operations in two groups:
#
# Group 1 (4 tests):
# 1. kb_add: 100 + 200 = 300
# 2. kb_sub wrap: 1 - 2 = p - 1 = 2130706432
# 3. kb_mul: 100000 * 100000 mod p = 1477174268
# 4. kb_pow3: 10000^3 mod p = 698682923
#
# Group 2 (4 tests):
# 5. kb_neg: -(100) = p - 100 = 2130706333
# 6. kb_double: 2 * 500000000 = 1000000000
# 7. kb_sub: 300 - 100 = 200
# 8. kb_add wrap: (p-1) + 2 = 1
#
# Expected output: [1, 200, 1000000000, 2130706333, 698682923, 1477174268, 2130706432, 300, 0, 0, 0, 0, 0, 0, 0, 0]

proc kb_reduce
    dup
    push.0x7F000001
    u32lt
    if.true
    else
        push.0x7F000001
        u32wrapping_sub
    end
end

proc kb_add
    u32overflowing_add
    if.true
        push.0x7F000001
        u32wrapping_sub
    else
        exec.kb_reduce
    end
end

proc kb_sub
    u32overflowing_sub
    if.true
        push.0x7F000001
        u32wrapping_add
    end
end

proc kb_mul
    u32overflowing_mul
    dup eq.0
    if.true
        drop
        exec.kb_reduce
    else
        swap swap
        push.33554430
        u32overflowing_mul
        swap movup.2
        u32overflowing_add
        movup.2 add
        dup eq.0
        if.true
            drop
            exec.kb_reduce
        else
            swap swap
            push.33554430
            u32overflowing_mul
            swap movup.2
            u32overflowing_add
            movup.2 add
            dup eq.0
            if.true
                drop
                exec.kb_reduce
            else
                swap swap
                push.33554430
                u32overflowing_mul
                swap movup.2
                u32overflowing_add
                movup.2 add
                dup eq.0
                if.true
                    drop
                    exec.kb_reduce
                else
                    drop
                    exec.kb_reduce
                end
            end
        end
    end
end

proc kb_pow3
    dup dup
    exec.kb_mul
    exec.kb_mul
end

proc kb_neg
    dup eq.0
    if.true
    else
        push.0x7F000001
        swap
        u32wrapping_sub
    end
end

proc kb_double
    dup
    exec.kb_add
end

begin
    # Group 1 (4 tests) - pushed onto stack
    # Test 1: 100 + 200 = 300
    push.100 push.200 exec.kb_add

    # Test 2: 1 - 2 = p - 1 = 2130706432
    push.1 push.2 exec.kb_sub

    # Test 3: 100000 * 100000 mod p = 1477174268
    push.100000 push.100000 exec.kb_mul

    # Test 4: 10000^3 mod p = 698682923
    push.10000 exec.kb_pow3

    # Stack now: [698682923, 1477174268, 2130706432, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    # That's 4 results + 16 initial = 20 elements

    # Drop 4 zeros from deep stack
    swapdw                      # Swap 0-3 with 4-7
    drop drop drop drop         # Drop 4 zeros
    # Now: 16 elements: [698682923, 1477174268, 2130706432, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    # Group 2 (4 more tests)
    # Test 5: -(100) = 2130706333
    push.100 exec.kb_neg

    # Test 6: 2 * 500000000 = 1000000000
    push.500000000 exec.kb_double

    # Test 7: 300 - 100 = 200
    push.300 push.100 exec.kb_sub

    # Test 8: (p-1) + 2 = 1
    push.0x7F000000 push.2 exec.kb_add

    # Stack now: [1, 200, 1000000000, 2130706333, 698682923, 1477174268, 2130706432, 300, 0*12] = 20 elements

    # Drop 4 more zeros
    swapdw
    drop drop drop drop
    # Final: 16 elements
end
